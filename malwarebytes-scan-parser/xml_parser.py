# FUNCTIONALITY EXPECTED:
# Done:
# - Returns <items> if threats are found - DONE
# - Returns message if no threats are found - DONE
# - Returns date of DB's used - DONE
# - Allows for file drop into CLI - DONE
# - Display how many threats were found per file - DONE
# - Remove extraneous modules - DONE
# - Parses XML File (returns error if file is not XML) - DONE
# - Add classes for cleaner code - DONE

# To-Do:
# - Can be compiled into exe
# - Refactor code
# - init function - MAY NOT BE NEEDED



from os import error
import sys
import re
from datetime import date, datetime
import xml.etree.ElementTree as ET
from collections import Counter


# Global Arrays Used in tool
singleThreatArr1 = []
singleThreatArr2 = []
multiThreatArr1 = []
multiThreatArr2 = []
uniquePosListArr = []

# Global Dicts Used in Tool
threatDict = {}

# Takes input variable from bat script
drop_file = sys.argv[1]


class mainClass:

    # Parse and extract the XML
    def readFile(file):
        tree = ET.parse(file)
        root = tree.getroot()
        return root

    # Method that defines the last time that the Databases have been updated
    def timeMethod():
        
        # Define current day
        dateTodayObj = date.today()

        # Convert date to str
        def convertCurrentDayToStr(date):
            today = datetime.strftime(date, "%Y-%m-%d")
            return(today)

        # Func that will convert date to int
        def convertDateToInt(date):
            intDate = datetime.strptime(date, "%Y-%m-%d")
            return intDate

        # Compare delta of dates
        def numOfDaysDifference(date1, date2):
            return (date1 - date2).days

        # Evals date/version of databases used
        def engineReview():
            # for child in readFile(drop_file)[1]: REENABLE FOR FINAL TEST
            for child in mainClass.readFile(drop_file)[1]:
                childText = child.text
                childTag = child.tag
                # replace characters in output for comparison
                convertChild = childText.replace(".", "-", 2).replace("v", "")
                
                if childTag == 'malware-database':
                    # remove last 3 chars from str for matching
                    sliceChild = convertChild[:-3]
                    # define time since malware db was updated
                    if sliceChild < convertCurrentDayToStr(dateTodayObj):
                        convertChildDate = convertDateToInt(sliceChild)
                        convertDayDate = convertDateToInt(convertCurrentDayToStr(dateTodayObj))
                        dateDiff = numOfDaysDifference(convertDayDate, convertChildDate)
                        print(f'The malware database is {dateDiff} days old')
                    else:
                        print('The malware database is current')
                elif childTag == 'rootkit-database':
                    # remove last 3 chars from str for matching
                    sliceChild = convertChild[:-3]
                    # define time since rootkit db was updated
                    if sliceChild < convertCurrentDayToStr(dateTodayObj):
                        convertChildDate = convertDateToInt(sliceChild)
                        convertDayDate = convertDateToInt(convertCurrentDayToStr(dateTodayObj))
                        dateDiff = numOfDaysDifference(convertDayDate, convertChildDate)
                        print(f'The rootkit database is {dateDiff} days old \n')
                    else:
                        print('The rootkit database is current \n')
                # define version of MBR
                elif childTag == 'version':
                    print(f'The version of Malwarebytes Breach Remediation is {child.text}')

        engineReview()
   
    # Method that returns results of the scan
    def dataMethod():

        # Evals input list and returns duplicate elements in new list
        def returnDuplicatesFromList(input):
            seen = set()
            seen_add = seen.add
            # adds all elements it doesn't know yet to seen and all other to seen_twice
            seen_twice = set( x for x in input if x in seen or seen_add(x) )
            # turn the set into a list (as requested)
            return list( seen_twice )

        # Evals input list and returns all non-duplicate elements in new list
        def removeDuplicatesFromList(input):
            list1 = input
            seen = set()
            seen_add = seen.add
            # adds all elements it doesn't know yet to seen and all other to seen_twice
            seen_twice = set( x for x in list1 if x in seen or seen_add(x) )
            # turn the set into a list (as requested)
            list2 = list( seen_twice )
            # compares lists for matching vals and returns new list
            list3 = [x for x in list1 if x not in list2]
            return list3

        # Checks how many items are in the list
        def countListItems(input):
            result = dict(Counter(input))
            return result

        # Generate Unique List of Threat Positions
        def findUniqueMultiThreats():
            # create variables to be used/updated throughout func
            oldList = getIndexForMultiThreat()
            uniqueList = returnDuplicatesFromList(oldList)
            uniqueList.sort()
            checkDict = countListItems(oldList)
            newList = []

            for key in checkDict:
                if checkDict[key] > 1:
                    for x in range(key, checkDict[key] + key):
                        newList.append(x)

            return newList
        # Returns index position array for single-threats in <items>
        def getIndexForSingleThreat():
            returnArr = []
            for child in mainClass.readFile(drop_file)[5]:

                # convert child to string & build regex to extract chars between ''
                childStr = str(child)
                rex = r'.*?\'(.*)\'.*'
                match = re.search(rex, childStr).group(1)

                # push matched vals to arr
                singleThreatArr1.append(match)

                for el in singleThreatArr1:
                    # print(singleThreatArr1)

                    # find index position of arr elements & push index to another arr
                    indexPos = singleThreatArr1.index(el)
                    singleThreatArr2.append(indexPos)

                    # extracting and appending the index positions compared to the length of singleThreatArr1
                    extracted = singleThreatArr2[-len(singleThreatArr1):]
                    # print(extracted)
                    returnArr.append(extracted)

            # return the last element of the arr
            return returnArr[-1]

        # Returns index position array for multi-threats in <items>
        def getIndexForMultiThreat():
            returnArr = []
            for child in mainClass.readFile(drop_file)[5]:
                childStr = str(child)
                rex = r'.*?\'(.*)\'.*'
                match = re.search(rex, childStr).group(1)
                multiThreatArr1.append(match)
                for el in multiThreatArr1:
                    indexPos = multiThreatArr1.index(el)
                    multiThreatArr2.append(indexPos)
                    extracted = multiThreatArr2[-len(multiThreatArr1):]
                    returnArr.append(extracted)
            return returnArr[-1]


        # Prints message that scan was clean - No threats found
        def noThreatFunc():
            print(f'Scan is clean - No threats detected \n')
            for child in mainClass.readFile(drop_file)[3]:
                childTag = child.tag
                if childTag != 'type' and childTag != 'result' and childTag != 'objects' and childTag != 'time':
                    print(f'Item scanned:\n {childTag.upper()}')

        # Prints <items> tied to index position for single-threat
        def singleThreatFunc():
            # get index position array
            val = removeDuplicatesFromList(getIndexForSingleThreat())
            printValue = '1'

            # check to see how many matches are found and print appropriate message
            if len(threatDict.keys()) == 1:
                print('The below item contains a threat, please review')
                for key in threatDict:
                    if threatDict[key] == '1':
                        print(f'{key.upper()} - {threatDict[key]}')
            elif len(threatDict.keys()) > 1 and any([True for k,v in threatDict.items() if v == printValue]):
                print(f'The following areas contain one threat each, please review in order of returned results:')
                for key in threatDict:
                    if threatDict[key] == '1':
                        print(f'{key.upper()} - {threatDict[key]}')

            # loop through arr with index positions 
            for el in val:
                for child in mainClass.readFile(drop_file)[5][el]:
                        print(f'       {child.tag} : {child.text}')
                        if child.tag == "hash":
                            print(f'\n')

        # Prints <items> tied to index position for multi-threats
        def multiThreatFunc():
            valTotal = findUniqueMultiThreats()
            printValue = '1'

            # check to see how many matches are found and print appropriate message
            if len(threatDict.keys()) == 1 and any([True for k,v in threatDict.items() if v > printValue]):
                print('The below item contains multiple threats, please review')
                for key in threatDict:
                    if threatDict[key] > '1':
                        print(f'print{key.upper()} - {threatDict[key]}')
            elif len(threatDict.keys()) > 1 and any([True for k,v in threatDict.items() if v > printValue]):
                print(f'The following areas contain multiple threats each, please review in order of returned results:')
                for key in threatDict:
                    if threatDict[key] > '1':
                        print(f'{key.upper()} - {threatDict[key]}')
                    
            # loop through arr with index positions 
            for el in valTotal:
                for child in mainClass.readFile(drop_file)[5][el]:
                        print(f'       {child.tag} : {child.text}')
                        if child.tag == "hash":
                            print(f'\n')

        #  Defines whether there are any found threats in the XML output
        def idThreats():
            # boolean check
            ifTrueForThreat = 0
            
            # parse the XML file
            # for child in readFile(drop_file)[3]: ***REENABLE FOR FINAL TEST
            for child in mainClass.readFile(drop_file)[3]:
                childText = child.text
                childTag = child.tag

                #  show whether a threat was identified in the results
                if childTag != 'type' and childTag != 'result' and childTag != 'objects' and childTag != 'time':
                    if childText == '1':
                        threatDict.update({childTag : childText})
                        ifTrueForThreat += 1
                    elif childText >= '2':
                        threatDict.update({childTag : childText})
                        ifTrueForThreat += 2


            # call func based on boolean 
            if ifTrueForThreat:
                singleThreatFunc()
                multiThreatFunc()
            else:
                noThreatFunc()
        idThreats()        
    


try:
    if ".XML" not in drop_file:
        raise Exception
    else:
        mainClass.timeMethod()
        mainClass.dataMethod()
except:
    print('Not an XML file, please try again...')

input('Press <Enter> to exit...')
